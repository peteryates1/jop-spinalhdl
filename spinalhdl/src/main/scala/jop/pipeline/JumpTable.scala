package jop.pipeline

import spinal.core._
import jop.JumpTableData

/**
 * Jump Table Init Data - microcode-layout-specific addresses and entries.
 *
 * Holds the 256-entry jump table plus special handler addresses.
 * Use JumpTableInitData.simulation for SIMULATION microcode (default),
 * and JumpTableInitData.serial for SERIAL-boot microcode.
 */
case class JumpTableInitData(
  entries:     Seq[BigInt],
  sysNoimAddr: Int,
  sysIntAddr:  Int,
  sysExcAddr:  Int
)

object JumpTableInitData {
  /** Default: SIMULATION microcode jump table */
  def simulation: JumpTableInitData = JumpTableInitData(
    entries     = JumpTableData.entries,
    sysNoimAddr = JumpTableData.sysNoimAddr,
    sysIntAddr  = JumpTableData.sysIntAddr,
    sysExcAddr  = JumpTableData.sysExcAddr
  )

  /** SERIAL-boot microcode jump table */
  def serial: JumpTableInitData = JumpTableInitData(
    entries     = jop.SerialJumpTableData.entries,
    sysNoimAddr = jop.SerialJumpTableData.sysNoimAddr,
    sysIntAddr  = jop.SerialJumpTableData.sysIntAddr,
    sysExcAddr  = jop.SerialJumpTableData.sysExcAddr
  )
}

/**
 * Jump Table Configuration
 *
 * Configures the jump table parameters for bytecode-to-microcode address translation.
 *
 * @param pcWidth  Address bits of microcode ROM (default: 11 bits = 2K instructions)
 * @param initData Jump table init data (default: simulation microcode)
 */
case class JumpTableConfig(
  pcWidth:  Int              = 11,
  initData: JumpTableInitData = JumpTableInitData.simulation
) {
  require(pcWidth > 0, "PC width must be positive")
  require(pcWidth <= 16, "PC width too large (max 16 bits)")

  /** Number of bytecode entries (always 256 for Java bytecode) */
  def entries: Int = 256
}

/**
 * Jump Table - Java Bytecode to Microcode Address Translation
 *
 * Translates 8-bit Java bytecode opcodes to microcode ROM addresses.
 * Uses ROM-based lookup with data generated by Jopa assembler.
 *
 * Architecture:
 * - ROM with 256 entries (one per bytecode 0x00-0xFF)
 * - Asynchronous/combinational read
 * - Initialized from JumpTableData.scala (generated by Jopa)
 *
 * Data Flow:
 * 1. bytecode (8 bits) → ROM address
 * 2. ROM lookup (combinational)
 * 3. jpaddr (pcWidth bits) → microcode fetch stage
 *
 * Special Addresses (from JumpTableData):
 * - sys_noim (0x0EC): Not implemented instruction handler
 * - sys_int  (0x0DA): Interrupt handler
 * - sys_exc  (0x0E2): Exception handler
 *
 * Timing:
 * - Combinational output (0 cycle latency)
 * - Used as address input to microcode ROM
 *
 * Generated From:
 * - asm/generated/JumpTableData.scala (auto-generated by Jopa)
 * - Original: original/vhdl/core/jtbl.vhd
 *
 * @param config Jump table configuration
 */
case class JumpTable(
  config: JumpTableConfig = JumpTableConfig()
) extends Component {

  val io = new Bundle {
    val bytecode = in Bits(8 bits)              // Java bytecode opcode (0x00-0xFF)
    val jpaddr   = out UInt(config.pcWidth bits) // Microcode ROM address

    // Interrupt/exception priority muxing (Phase E)
    val intPend = in Bool()                     // Interrupt pending
    val excPend = in Bool()                     // Exception pending
  }

  // ==========================================================================
  // Jump Table ROM
  // ==========================================================================

  // ROM stores microcode addresses (256 entries, one per bytecode)
  val rom = Mem(UInt(config.pcWidth bits), config.entries)

  // Initialize from provided jump table data
  rom.init(config.initData.entries.map(addr => U(addr.toInt, config.pcWidth bits)))

  // ==========================================================================
  // Lookup Logic
  // ==========================================================================

  // Asynchronous ROM read (combinational, 0-cycle latency)
  // bytecode → ROM address → microcode address
  // Note: readAsync generates a Verilog warning "can only be write first"
  //       This is safe here since ROM has no writes (read-only data)
  val normalAddr = rom.readAsync(io.bytecode.asUInt)

  // Priority muxing: Exception > Interrupt > Normal bytecode
  // This matches VHDL jtbl.vhd behavior
  when(io.excPend) {
    io.jpaddr := U(config.initData.sysExcAddr, config.pcWidth bits)
  }.elsewhen(io.intPend) {
    io.jpaddr := U(config.initData.sysIntAddr, config.pcWidth bits)
  }.otherwise {
    io.jpaddr := normalAddr
  }

  // ==========================================================================
  // Verification Helpers
  // ==========================================================================

  // Add assertions for debugging (disabled in synthesis)
  if (GenerationFlags.simulation) {
    // Verify bytecode is in valid range
    assert(
      assertion = io.bytecode.asUInt < config.entries,
      message = "Invalid bytecode out of range",
      severity = WARNING
    )

    // Verify output address is in valid microcode ROM range
    assert(
      assertion = io.jpaddr < (1 << config.pcWidth),
      message = "Jump address out of microcode ROM range",
      severity = WARNING
    )
  }
}

/**
 * JumpTable Companion Object
 *
 * Provides utility functions and constants.
 */
object JumpTable {

  /**
   * Special microcode addresses (from JumpTableData)
   */
  object SpecialAddr {
    val SYS_NOIM = JumpTableData.sysNoimAddr  // 0x0EC - Not implemented
    val SYS_INT  = JumpTableData.sysIntAddr   // 0x0DA - Interrupt
    val SYS_EXC  = JumpTableData.sysExcAddr   // 0x0E2 - Exception
  }

  /**
   * Get microcode address for a specific bytecode (for testing)
   */
  def getAddress(bytecode: Int): Int = {
    require(bytecode >= 0 && bytecode < 256, "Bytecode out of range")
    JumpTableData.entries(bytecode).toInt
  }

  /**
   * Generate Verilog for standalone testing
   */
  def main(args: Array[String]): Unit = {
    SpinalConfig(
      mode = Verilog,
      targetDirectory = "core/spinalhdl/generated"
    ).generate(JumpTable())
  }
}
