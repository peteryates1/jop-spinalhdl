# Phase A: Bytecode Fetch Stage - Implementation Status

**Date:** 2026-01-05
**Status:** IN PROGRESS

---

## Summary

Phase A focused on implementing the bytecode fetch stage components. **JumpTable is complete and working**. **BytecodeFetchStage is implemented but has timing issues** requiring debugging.

## Completed Components

### ✅ JumpTable (COMPLETE - 5/5 tests passing)

**File:** `core/spinalhdl/src/main/scala/jop/pipeline/JumpTable.scala` (128 lines)

**Features:**
- ROM-based lookup table (256 entries)
- Initialized from auto-generated `JumpTableData.scala`
- Combinational output (0-cycle latency)
- Helper functions and constants

**Test Results:**
```
✅ Known bytecode mappings
✅ All 256 entries present and correct
✅ Unmapped bytecodes route to sys_noim (0x0EC)
✅ Special addresses match JumpTableData
✅ Helper function getAddress() works
```

**Generated Data:**
- `asm/generated/JumpTableData.scala` (282 lines, auto-generated by Jopa)
- 188 implemented instructions
- 68 unmapped bytecodes routing to sys_noim handler

---

## In Progress Components

### ⚠️ BytecodeFetchStage (IMPLEMENTED - 1/4 tests passing)

**File:** `core/spinalhdl/src/main/scala/jop/pipeline/BytecodeFetchStage.scala` (147 lines - simplified version)

**Implemented Features:**
- Java PC (jpc) register (12-bit)
- JBC RAM (synchronous read, 2KB)
- JumpTable integration
- JPC update logic with priority (jpc_wr > jfetch > hold)

**Not Yet Implemented (deferred):**
- Operand accumulation (jopdfetch)
- Branch logic (15 branch types)
- Interrupt/exception handling

**Test Results:**
```
✅ Reset clears state (1/4 passing)
❌ JPC increments on jfetch (timing issue)
❌ JPC loads from stack (jpc_wr)
❌ JumpTable integration (synchronous RAM timing)
```

**Known Issues:**
1. **JPC register not updating**: Register assignments appear correct but values don't change
   - Likely: SpinalHDL register update timing issue
   - Need: Review register assignment patterns from FetchStage.scala

2. **Synchronous RAM timing**: JBC RAM uses synchronous read
   - Need: Extra wait cycles for RAM latency
   - Consider: Asynchronous read for simpler timing

**Simplified Approach:**
- Stripped complex features (branches, operands) to get baseline working
- Focus on: reset, JPC increment, JPC write, JumpTable integration
- Plan: Get basics working, then add features incrementally

---

## Build System Integration

### ✅ Jopa Assembler with Scala Generation

**Modifications:**
- `java/jopa/src/com/jopdesign/tools/Jopa.java`: Added `writeScalaJumpTable()` method
- `core/spinalhdl/build.sbt`: Added `asm/generated/` as source directory

**Generated Files:**
- `asm/generated/JumpTableData.scala` - Scala jump table (auto-generated)
- `asm/generated/jtbl.vhd` - VHDL jump table
- `asm/generated/rom.vhd` - Microcode ROM
- `asm/generated/mem_rom.dat`, `mem_ram.dat` - Simulation data

**Build Process:**
```bash
cd asm && make              # Generate all microcode files
cd core/spinalhdl && sbt compile  # Automatically includes JumpTableData.scala
```

---

## Testing Approach

**Decision:** Simplified approach (Option B from planning)
- Create SpinalHDL tests directly
- Defer full CocoTB/VHDL golden reference validation
- Reason: BytecodeFetchStage more complex than previous modules

**Current Test Coverage:**
- JumpTable: 5 tests, all passing
- BytecodeFetchStage: 4 tests, 1 passing

**Future Work:**
- Create CocoTB tests against VHDL bcfetch.vhd
- Extract test vectors
- Validate SpinalHDL against VHDL golden reference

---

## Next Steps

### Immediate (Debug BytecodeFetchStage)

1. **Fix JPC register timing**
   - Review FetchStage.scala register patterns
   - Check SpinalHDL register assignment rules
   - Add simulation debug output

2. **Fix synchronous RAM timing**
   - Add proper wait cycles for RAM latency
   - Or switch to asynchronous read

3. **Get 4/4 basic tests passing**
   - Reset
   - JPC increment
   - JPC write (jpc_wr)
   - JumpTable integration

### Incremental Feature Addition

4. **Add operand accumulation (jopdfetch)**
   - 16-bit jopd register
   - Shift low → high byte logic
   - Test multi-byte operands

5. **Add branch logic**
   - Branch type decode (15 types)
   - Condition evaluation
   - Branch target calculation
   - Test all branch conditions

6. **Integration testing**
   - Create JopCoreWithBytecode
   - End-to-end bytecode execution
   - Test simple JVM sequences

---

## Files Created/Modified

### New Files
- `core/spinalhdl/src/main/scala/jop/pipeline/JumpTable.scala` (128 lines)
- `core/spinalhdl/src/main/scala/jop/pipeline/BytecodeFetchStage.scala` (147 lines)
- `core/spinalhdl/src/test/scala/jop/pipeline/JumpTableTest.scala` (97 lines)
- `core/spinalhdl/src/test/scala/jop/pipeline/BytecodeFetchStageTest.scala` (177 lines)
- `asm/generated/JumpTableData.scala` (282 lines, auto-generated)
- `docs/PHASE-A-STATUS.md` (this file)

### Modified Files
- `java/jopa/src/com/jopdesign/tools/Jopa.java` (+77 lines)
- `core/spinalhdl/build.sbt` (+3 lines)
- `docs/JOPA_TOOL.md` (diagram fix)
- `README.md` (added asm/, java/jopa/, build system docs)

---

## Lessons Learned

1. **Start simple, add complexity incrementally**
   - Initial BytecodeFetchStage was too complex (398 lines)
   - Simplified to 147 lines focusing on core functionality
   - Easier to debug when isolated

2. **SpinalHDL timing is subtle**
   - Register updates have specific timing rules
   - Synchronous vs asynchronous memory reads matter
   - Need to carefully match VHDL timing behavior

3. **Testing approach matters**
   - JumpTable: Simple, self-contained, easy to test → 100% success
   - BytecodeFetchStage: Complex, many interactions → needs debugging
   - Golden reference tests (CocoTB) would help validate behavior

4. **Generated code integration works well**
   - Jopa modification successful
   - Build system integration clean
   - Single source of truth for jump table

---

## Status: Ready to Commit

**What works:**
- ✅ JumpTable component (fully tested)
- ✅ Jopa Scala generation
- ✅ Build system integration

**What needs work:**
- ⚠️ BytecodeFetchStage register timing
- ⚠️ Test coverage (need full functionality tests)

**Recommendation:** Commit current progress with documented status, debug BytecodeFetchStage in next session.
