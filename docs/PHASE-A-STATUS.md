# Phase A: Bytecode Fetch Stage - Implementation Status

**Date:** 2026-01-05
**Status:** COMPLETE (9/9 tests passing)

---

## Summary

Phase A focused on implementing the bytecode fetch stage components. **JumpTable is complete and working (5/5 tests)**. **BytecodeFetchStage is complete and working (4/4 tests)**. All basic functionality tested and verified.

## Completed Components

### ✅ JumpTable (COMPLETE - 5/5 tests passing)

**File:** `core/spinalhdl/src/main/scala/jop/pipeline/JumpTable.scala` (128 lines)

**Features:**
- ROM-based lookup table (256 entries)
- Initialized from auto-generated `JumpTableData.scala`
- Combinational output (0-cycle latency)
- Helper functions and constants

**Test Results:**
```
✅ Known bytecode mappings
✅ All 256 entries present and correct
✅ Unmapped bytecodes route to sys_noim (0x0EC)
✅ Special addresses match JumpTableData
✅ Helper function getAddress() works
```

**Generated Data:**
- `asm/generated/JumpTableData.scala` (282 lines, auto-generated by Jopa)
- 188 implemented instructions
- 68 unmapped bytecodes routing to sys_noim handler

---

## Completed Components (Continued)

### ✅ BytecodeFetchStage (COMPLETE - 4/4 tests passing)

**File:** `core/spinalhdl/src/main/scala/jop/pipeline/BytecodeFetchStage.scala` (147 lines - simplified version)

**Implemented Features:**
- Java PC (jpc) register (12-bit)
- JBC RAM (synchronous read, 2KB)
- JumpTable integration
- JPC update logic with priority (jpc_wr > jfetch > hold)

**Not Yet Implemented (deferred):**
- Operand accumulation (jopdfetch)
- Branch logic (15 branch types)
- Interrupt/exception handling

**Test Results:**
```
✅ Reset clears state (1/4)
✅ JPC increments on jfetch (2/4)
✅ JPC loads from stack (jpc_wr) (3/4)
✅ JumpTable integration (synchronous RAM timing) (4/4)
```

**Issues Resolved:**
1. **SpinalHDL simulation timing**: Added `sleep(1)` after `waitSampling()` to allow combinational logic to settle
   - Solution: Standard pattern for SpinalHDL tests after clock edges

2. **Synchronous RAM timing**: JBC RAM readSync has 1-cycle latency
   - Solution: Clear jfetch after one cycle to prevent double increment
   - Test timing: Set jfetch=true, wait 1 cycle, clear jfetch=false, wait 1 cycle for RAM output

**Simplified Approach (Success):**
- Stripped complex features (branches, operands) to get baseline working ✅
- Focus on: reset, JPC increment, JPC write, JumpTable integration ✅
- Plan: Get basics working, then add features incrementally

---

## Build System Integration

### ✅ Jopa Assembler with Scala Generation

**Modifications:**
- `java/jopa/src/com/jopdesign/tools/Jopa.java`: Added `writeScalaJumpTable()` method
- `core/spinalhdl/build.sbt`: Added `asm/generated/` as source directory

**Generated Files:**
- `asm/generated/JumpTableData.scala` - Scala jump table (auto-generated)
- `asm/generated/jtbl.vhd` - VHDL jump table
- `asm/generated/rom.vhd` - Microcode ROM
- `asm/generated/mem_rom.dat`, `mem_ram.dat` - Simulation data

**Build Process:**
```bash
cd asm && make              # Generate all microcode files
cd core/spinalhdl && sbt compile  # Automatically includes JumpTableData.scala
```

---

## Testing Approach

**Decision:** Simplified approach (Option B from planning)
- Create SpinalHDL tests directly
- Defer full CocoTB/VHDL golden reference validation
- Reason: BytecodeFetchStage more complex than previous modules

**Current Test Coverage:**
- JumpTable: 5 tests, all passing
- BytecodeFetchStage: 4 tests, 1 passing

**Future Work:**
- Create CocoTB tests against VHDL bcfetch.vhd
- Extract test vectors
- Validate SpinalHDL against VHDL golden reference

---

## Next Steps

### Immediate (Debug BytecodeFetchStage)

1. **Fix JPC register timing**
   - Review FetchStage.scala register patterns
   - Check SpinalHDL register assignment rules
   - Add simulation debug output

2. **Fix synchronous RAM timing**
   - Add proper wait cycles for RAM latency
   - Or switch to asynchronous read

3. **Get 4/4 basic tests passing**
   - Reset
   - JPC increment
   - JPC write (jpc_wr)
   - JumpTable integration

### Incremental Feature Addition

4. **Add operand accumulation (jopdfetch)**
   - 16-bit jopd register
   - Shift low → high byte logic
   - Test multi-byte operands

5. **Add branch logic**
   - Branch type decode (15 types)
   - Condition evaluation
   - Branch target calculation
   - Test all branch conditions

6. **Integration testing**
   - Create JopCoreWithBytecode
   - End-to-end bytecode execution
   - Test simple JVM sequences

---

## Files Created/Modified

### New Files
- `core/spinalhdl/src/main/scala/jop/pipeline/JumpTable.scala` (128 lines)
- `core/spinalhdl/src/main/scala/jop/pipeline/BytecodeFetchStage.scala` (147 lines)
- `core/spinalhdl/src/test/scala/jop/pipeline/JumpTableTest.scala` (97 lines)
- `core/spinalhdl/src/test/scala/jop/pipeline/BytecodeFetchStageTest.scala` (177 lines)
- `asm/generated/JumpTableData.scala` (282 lines, auto-generated)
- `docs/PHASE-A-STATUS.md` (this file)

### Modified Files
- `java/jopa/src/com/jopdesign/tools/Jopa.java` (+77 lines)
- `core/spinalhdl/build.sbt` (+3 lines)
- `docs/JOPA_TOOL.md` (diagram fix)
- `README.md` (added asm/, java/jopa/, build system docs)

---

## Lessons Learned

1. **Start simple, add complexity incrementally**
   - Initial BytecodeFetchStage was too complex (398 lines)
   - Simplified to 147 lines focusing on core functionality
   - Easier to debug when isolated

2. **SpinalHDL timing is subtle**
   - Register updates have specific timing rules
   - Synchronous vs asynchronous memory reads matter
   - Need to carefully match VHDL timing behavior

3. **Testing approach matters**
   - JumpTable: Simple, self-contained, easy to test → 100% success
   - BytecodeFetchStage: Complex, many interactions → needs debugging
   - Golden reference tests (CocoTB) would help validate behavior

4. **Generated code integration works well**
   - Jopa modification successful
   - Build system integration clean
   - Single source of truth for jump table

---

## Status: Complete - Ready to Commit

**What works:**
- ✅ JumpTable component (5/5 tests passing)
- ✅ BytecodeFetchStage component (4/4 tests passing)
- ✅ Jopa Scala generation
- ✅ Build system integration

**Test Coverage:**
- JumpTable: 5 tests covering all 256 entries, special addresses, helper functions
- BytecodeFetchStage: 4 tests covering reset, JPC increment, JPC write, JumpTable integration

**Phase A Completion:**
- All basic bytecode fetch functionality implemented and tested
- Simplified implementation approach successful
- Ready for incremental feature addition (operands, branches) in future phases

**Recommendation:** Commit completed Phase A implementation.
