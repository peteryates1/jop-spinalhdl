# Microcode Operations

Reference extracted from `microcode.csv` and `java/tools/src/com/jopdesign/tools/Instruction.java`. Opcodes and dataflow use ASCII; arrows are written as `->`.

| Microcode | Operation | Opcode | Dataflow | JVM equivalent | Description |
| --- | --- | --- | --- | --- | --- |
| add | Add int | `0000000100` | `A+B -> A`<br>`stack[sp] -> B`<br>`sp-1 -> sp` | iadd | Add the two top elements from the stack and push back the result onto the operand stack. |
| and | Boolean AND int | `0000000001` | `A & B -> A`<br>`stack[sp] -> B`<br>`sp-1 -> sp` | iand | Build the bitwise AND (conjunction) of the two top elements of the stack and push back the result onto the operand stack. |
| atmend | End atomic arbiter operation | `0100010011` | `-` | -- | end atomic arbiter operation |
| atmstart | Start atomic arbiter operation | `0100010010` | `-` | -- | start atomic arbiter operation |
| bnz | Branch if value is not zero | `0111nnnnnn` | `if A != 0 then pc + sign_ext(nnnnnn) + 1 -> pc`<br>`B->A`<br>`stack[sp] -> B`<br>`sp - 1 -> sp` | -- | If the top value from the operand stack is not zero a microcode branch is taken. The value is popped from the operand stack. Due to a pipeline delay the zero flag is delayed one cycle i.e. the value from the last but one instruction is taken. The branch is followed by two branch delay slots. The branch offset is the signed 6-bit immediate. |
| bz | Branch if value is zero | `0110nnnnnn` | `if A = 0 then pc + sign_ext(nnnnnn) + 1 -> pc`<br>`B->A`<br>`stack[sp] -> B`<br>`sp - 1 -> sp` | -- | If the top value from the operand stack is zero a microcode branch is taken. The value is popped from the operand stack. Due to a pipeline delay the zero flag is delayed one cycle i.e. the value from the last but one instruction is taken. The branch is followed by two branch delay slots. The branch offset is the signed 6-bit immediate. |
| cinval | Invalidate data cache | `0100010001` | `-` | -- | invalidate data cache |
| dup | Duplicate the top operand stack value | `0011111000` | `A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | dup | Duplicate the top value on the operand stack and push it onto the operand stack. |
| jbr | Conditional bytecode branch and goto | `0100000010` | `-` | ifnull, Ifnonnull, Ifeq, Ifne, Iflt, Ifge, Ifgt, Ifle, if_acmpeq, if_acmpne, if_icmpeq, if_icmpne, if_icmplt, if_icmpge, if_icmpgt, if_icmple, goto | Execute a bytecode branch or goto. The branch condition and offset are calculated in the bytecode fetch unit. Arguments must be removed with ```pop``` instructions in the following microcode instructions. |
| jmp | Unconditional jump | `1nnnnnnnnn` | `pc + sign_ext(nnnnnnnnn) + 1 -> pc` | -- | Microcode branch. The branch offset is the signed 9-bit immediate. |
| ld | Load 32-bit word from local variable | `0011101100` | `stack[vp+opd] to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | aload, Iload, fload | The local variable at position $opd$ is pushed onto the operand stack. $opd$ is taken from the bytecode instruction stream. |
| ld[n] | Load 32-bit word from local variable | `00111010nn` | `stack[vp+n] to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | aload_n, iload_n, fload_n | The local variable at position $n$ is pushed onto the operand stack. |
| ld_opd_16s | Load 16-bit bytecode operand signed | `0011110111` | `opd_{16} to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | (sipush) | A 16-bit word from the bytecode stream is sign-extended to an ```int``` and pushed onto the operand stack. |
| ld_opd_16u | Load 16-bit bytecode operand unsigned | `0011110110` | `opd_{16} to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | A 16-bit word from the bytecode stream is pushed as ```int``` onto the operand stack. |
| ld_opd_8s | Load 8-bit bytecode operand signed | `0011110101` | `opd to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | (bipush) | A single byte from the bytecode stream is sign-extended to an ```int``` and pushed onto the operand stack. |
| ld_opd_8u | Load 8-bit bytecode operand unsigned | `0011110100` | `opd to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | A single byte from the bytecode stream is pushed as ```int``` onto the operand stack. |
| ldbcstart | Load method start | `0011100010` | `bcstart to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`sp+1 to sp` | -- | The method start address in the method cache is pushed onto the operand stack. |
| ldi | Load from local memory | `00110nnnnn` | `stack[n+32] to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`sp+1 to sp` | -- | The value from the local memory (stack) at position $n+32$ is pushed onto the operand stack. These 32 memory destinations represent microcode constants. |
| ldjpc | Load Java program counter | `0011110010` | `jpc to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | The Java program counter is pushed onto the operand stack. |
| ldm | Load from local memory | `00101nnnnn` | `stack[n] to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | The value from the local memory (stack) at position $n$ is pushed onto the operand stack. These 32 memory destinations represent microcode local variables. |
| ldmi | Load from local memory indirect | `0011101101` | `stack[ar] to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | The value from the local memory (stack) at position ar is pushed onto the operand stack. |
| ldmrd | Load memory read data | `0011100000` | `memrdd to A`<br>`A to B`<br>`B to stack`<br>`[sp+1]+1 to sp` | -- | The value from the memory system after a memory read is pushed onto the operand stack. This operation is usually preceded by two ```wait``` instructions. |
| ldmul | Load multiplier result | `0011100001` | `mulr to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | (imul) | The result of the multiplier is pushed onto the operand stack. |
| ldsp | Load stack pointer | `0011110000` | `sp to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | The stack pointer is pushed onto the operand stack. |
| ldvp | Load variable pointer | `0011110001` | `vp to A`<br>`A to B`<br>`B to stack[sp+1]`<br>`Sp+1 to sp` | -- | The variable pointer is pushed onto the operand stack. |
| nop | Do nothing | `0100000000` | `-` | nop | The famous no operation instruction. |
| or | Boolean OR int | `0000000010` | `A \| B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | ior | Build the bitwise inclusive OR (disjunction) of the two top elements of the stack and push back the result onto the operand stack. |
| pop | Pop the top operand stack value | `0000000000` | `B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | pop | Pop the top value from the operand stack. |
| shl | Shift left int | `0000011101` | `B << A to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | ishl | The values are popped from the operand stack. An ```int``` result is calculated by shifting the TOS-1 value left by $s$ position where $s$ is the value of the low 5 bits of the TOS. The result is pushed onto the operand stack. |
| shr | Arithmetic shift rigth int | `0000011110` | `B >> A to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | ishr | The values are popped from the operand stack. An ```int``` result is calculated by shifting the TOS-1 value rigth by $s$ position with sign extension where $s$ is the value of the low 5 bits of the TOS. The result is pushed onto the operand stack. |
| st | Store 32-bit word into local variable | `0000010100` | `A to stack[vp+opd]`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | astore, istore, fstore | The value on the top of the operand stack is popped and stored in the local variable at position $opd$. $opd$ is taken from the bytecode instruction stream. |
| st[n] | Store 32-bit word into local variable | `00000100nn` | `A to stack[vp+n]`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | astore_n, istore_n, fstore_n | The value on the top of the operand stack is popped and stored in the local variable at position $n$. |
| stald | Start array load | `0001000100` | `A to memidx`<br>`B to A`<br>`B to memptr`<br>`stack[sp] to B`<br>`sp-1 to sp` | xaload | The top value from the stack is stored as array index the next as reference in the memory subsystem. This operation starts the concurrent array load. The processor can continue with other operations. The ```wait``` instruction stalls the processor till the read access is finished. A null pointer or out of bounds exception is generated by the memory subsystem and thrown at the next bytecode fetch. |
| star | Store adress register | `0000011010` | `A to ar`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The value on the top of the operand stack is popped and stored in the address register (```ar```). Due to a pipeline delay the register is valid on cycle later for usage by ```ldmi``` and ```stmi```. |
| stast | Start array store | `0001000101` | `A to memval`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp`<br>`next cycle`<br>`A to memidx`<br>`B to A`<br>`B to memptr`<br>`stack[sp] to B`<br>`sp-1 to sp` | xastore | In the first cycle the top value from the stack is stored as value into the memory subsystem. A microcode ```pop``` has to follow. In the second cycle the top value from the stack is stored as array index the next as reference in the memory subsystem. This operation starts the concurrent array store. The processor can continue with other operations. The ```wait``` instruction stalls the processor till the write access is finished. A null pointer or out of bounds exception is generated by the memory subsystem and thrown at the next bytecode fetch. |
| stbcrd | Start bytecode read | `0001001001` | `A to membcr`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as address and length of a method in the memory subsystem. This operation starts the memory transfer from the main memory to the bytecode cache (DMA). The processor can continue with other operations. The ```wait``` instruction stalls the processor till the transfer has finished. No other memory accesses are allowed during the bytecode read. |
| stcp | Start copy step | `0001001000` | `A to memidx`<br>`B to memsrc`<br>`stack[sp] to B`<br>`sp-1 to sp`<br>`next cycle`<br>`B to memdest`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as index for a ```stgf``` and ```stgf```. One of those two instructions has to follow. |
| stgf | Start getfield | `0001000110` | `A to memptr`<br>`B to A`<br>`opd_{16} to memidx`<br>`stack[sp] to B`<br>`sp-1 to sp` | getfield | The top value from the stack is stored as reference in the memory subsystem. This operation starts the concurrent getfield. The processor can continue with other operations. The ```wait``` instruction stalls the processor till the read access is finished. A null pointer exception is generated by the memory subsystem and thrown at the next bytecode fetch. |
| stgs | Start getstatic | `0100010000` | `opd_{16} to memptr` | getstatic | The static field address is in the bytecode operand (index). |
| stidx | Store index for native field access | `0001001010` | `A to memidx`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as field index for native field access (```Native.get/putfield```) |
| stjpc | Store Java program counter | `0000011001` | `A to jpc`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The value on the top of the operand stack is popped and stored in the Java program counter (```jpc```). |
| stm | Store in local memory | `00001nnnnn` | `A to stack[n]`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the operand stack is stored in the local memory (stack) at position n. These 32 memory destinations represent microcode local variables. |
| stmi | Store in local memory indirect | `0000010101` | `A to stack[ar]`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the operand stack is stored in the local memory (stack) at position ar. |
| stmra | Store memory read address | `0001000010` | `A to memrda`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as read address in the memory subsystem. This operation starts the concurrent memory read. The processor can continue with other operations. When the datum is needed a ```wait``` instruction stalls the processor till the read access is finished. The value is read with ```ldmrd```. |
| stmul | Multiply int | `0001000000` | `A to mula`<br>`B to mulb`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as first operand for the multiplier. The value one below the top of stack is stored as second operand for the multiplier. This operation starts the multiplier. The result is read with the ```ldmul``` instruction. |
| stmwa | Store memory write address | `0001000001` | `A to memwra`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as write address in the memory subsystem for a following ```stmwd```. |
| stmwd | Store memory write data | `0001000011` | `A to memwrd`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The top value from the stack is stored as write data in the memory subsystem. This operation starts the concurrent memory write The processor can continue with other operations. The ```wait``` instruction stalls the processor till the write access is finished. |
| stpf | Start putfield | `0001000111` | `A to memval`<br>`B to A`<br>`B to memptr`<br>`opd_{16} to memidx`<br>`stack[sp] to B`<br>`sp-1 to sp` | putfield | In the first cycle the top value from the stack is stored as value into the memory subsystem. A microcode ```pop``` has to follow. This operation starts the concurrent putfield. The processor can continue with other operations. The ```wait``` instruction stalls the processor till the write access is finished. A null pointer exception is generated by the memory subsystem and thrown at the next bytecode fetch. |
| stpfr | Start putfield (reference check) | `0001001111` | `A to memval`<br>`B to A`<br>`B to memptr`<br>`opd_{16} to memidx`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | start putfield index is taken from the BC operand |
| stps | Start putstatic | `0001001011` | `A to memval`<br>`B to A`<br>`opd_{16} to memptr`<br>`stack[sp] to B` | putstatic | The top value from the stack is stored into the static field. The static field address is in the bytecode operand (index). |
| stmrac | Start memory constant read | `0001001100` | `A to memrda`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | stmrac	load a constant |
| stmraf | Start memory read through full assoc. cache | `0001001101` | `A to memrda`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | load through fully assoc. cache |
| stmwdf | Start memory write through full assoc. cache | `0001001110` | `A to memwrd`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | store through fully assoc. cache |
| stsp | Store stack pointer | `0000011011` | `A to sp`<br>`B to A`<br>`stack[sp] to B` | -- | The value on the top of the operand stack is popped and stored in the stack pointer (```sp```). |
| stvp | Store variable pointer | `0000011000` | `A to vp`<br>`B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | -- | The value on the top of the operand stack is popped and stored in the variable pointer (```vp```). |
| sub | Subtract int | `0000000101` | `A-B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | isub | Subtract the two top elements from the stack and push back the result onto the operand stack. |
| ushr | Logical shift rigth int | `0000011100` | `B >>> A to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | iushr | The values are popped from the operand stack. An ```int``` result is calculated by shifting the TOS-1 value rigth by $s$ position with zero extension where $s$ is the value of the low 5 bits of the TOS. The result is pushed onto the operand stack. |
| wait | Wait for memory completion | `0100000001` | `-` | -- | This instruction stalls the processor until a pending memory instruction (```stmra``` ```stmwd``` or ```stbcrd```) has completed. Two consecutive ```wait``` instructions are necessary for a correct stall of the decode and execute stage. |
| xor | Boolean XOR int | `0000000011` | `A ^ B to A`<br>`stack[sp] to B`<br>`sp-1 to sp` | ixor | Build the bitwise exclusive OR (negation of equivalence) of the two top elements of the stack and push back the result onto the operand stack. |
