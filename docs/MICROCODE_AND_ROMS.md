# Microcode and ROM Files

## Overview

The JOP processor uses a two-level execution model:
1. **Java bytecode** → translated to → **Microcode address** (via jump table)
2. **Microcode** → executed by the processor

These mappings are **generated files** created by the microcode assembler.

## Critical Generated Files

Location: `/home/peter/git/jop.arch/jop/asm/generated/`

### 1. jtbl.vhd - Jump Table (CRITICAL!)

**Purpose**: Translates Java bytecode to microcode ROM addresses

**File**: `/home/peter/git/jop.arch/jop/asm/generated/jtbl.vhd`

**What it does**:
- Input: 8-bit Java bytecode (0x00-0xFF)
- Output: 11-bit microcode ROM address
- Pure combinational logic (no registers)
- Maps each Java bytecode instruction to its microcode implementation

**Example**:
```vhdl
when "00000000" => addr <= "01000011000";  -- 0x00 (nop) → addr 0x218
when "00000001" => addr <= "01000011010";  -- 0x01 (aconst_null) → addr 0x21A
when "10111011" => addr <= "00001111110";  -- 0xBB (new) → addr 0x07E
```

**Generated by**: Jopa tool
- Location: `/home/peter/git/jop.arch/jop/java/tools/src/com/jopdesign/tools/Jopa.java`
- Java-based microcode assembler

**Used in**: bcfetch.vhd module

**SpinalHDL equivalent**: Will need to create similar ROM in Scala

### 2. rom.vhd - Microcode ROM

**Purpose**: Contains the actual microcode instructions

**File**: `/home/peter/git/jop.arch/jop/asm/generated/rom.vhd`

**What it does**:
- Stores microcode instruction sequences
- Addressed by the jump table output
- Contains the JVM implementation in microcode

**Size**: ~97KB of microcode

**Generated by**: Jopa tool from `jvmgen.asm`
- Location: `/home/peter/git/jop.arch/jop/java/tools/src/com/jopdesign/tools/Jopa.java`

**Used in**: fetch.vhd module

### 3. jvmgen.asm - Microcode Source

**Purpose**: Human-readable microcode assembly

**File**: `/home/peter/git/jop.arch/jop/asm/generated/jvmgen.asm`

**What it does**:
- Source code for the JVM implementation
- Written in JOP microcode assembly language
- Assembled into rom.vhd and jtbl.vhd

**Size**: ~52KB of assembly

**This is the JVM implementation!**

### 4. RAM Initialization Files

**Purpose**: Initialize stack buffer RAM

- **mem_ram.dat** - Stack buffer data (**RECOMMENDED**: Simple format, one decimal number per line)
- **ram.mif** - Stack buffer initialization (Altera MIF format - more complex)

**Format of mem_ram.dat**:
```
0
0
0
...
(one decimal value per line, one per address)
```

**Stack Buffer Layout**:
```
Address 0-31:   Variables (32 slots)
Address 32-63:  Constants (32 slots)
Address 64+:    Stack starts here (SP = 64 initially)
```

**Important**: Stack pointer (SP) should be initialized to 64, then grows upward from there.

### 5. ROM Initialization Files

**Purpose**: Initialize microcode ROM

- **mem_rom.dat** - Microcode ROM data (**RECOMMENDED**: Simple format, one decimal number per line)
- **rom.mif** - Microcode ROM initialization (Altera MIF format - more complex)
- **rom.vhd** - VHDL ROM implementation (most complex, don't parse this)

**Format of mem_rom.dat**:
```
256
256
192
...
(one decimal value per line, one microcode instruction per address)
```

Contains the actual microcode instructions that implement the JVM.

**Recommendation**: Use `mem_rom.dat` and `mem_ram.dat` for SpinalHDL - simplest to parse!

## Architecture Relationship

```
Java Bytecode (8 bits)
    ↓
┌─────────────┐
│   jtbl.vhd  │  Jump Table (combinational)
│  (generated)│  Maps bytecode → microcode address
└──────┬──────┘
       │ microcode address (11 bits)
       ↓
┌─────────────┐
│   rom.vhd   │  Microcode ROM
│  (generated)│  Contains microcode instructions
└──────┬──────┘
       │ microcode instruction
       ↓
   Execute in
  Stack/Decode
```

## Generation Process

```
jvm.asm (microcode source)
    ↓
 Jopa Tool (microcode assembler)
 Location: /home/peter/git/jop.arch/jop/java/tools/src/com/jopdesign/tools/Jopa.java
    ↓
Outputs to: /home/peter/git/jop.arch/jop/asm/generated/
  ├─→ jtbl.vhd (jump table VHDL)
  ├─→ rom.vhd (microcode ROM VHDL)
  ├─→ jvmgen.asm (annotated assembly with addresses)
  ├─→ rom.mif (Altera ROM format)
  ├─→ ram.mif (Altera RAM format)
  ├─→ mem_rom.dat (generic ROM - RECOMMENDED)
  └─→ mem_ram.dat (generic RAM - RECOMMENDED)
```

**To regenerate files**:
```bash
cd /home/peter/git/jop.arch/jop/asm
make
# Runs Jopa tool to generate all files in generated/
```

**Jopa Tool**:
- Written in Java
- Assembles microcode from assembly source
- Generates multiple output formats (VHDL, MIF, DAT)
- Creates jump table mapping
- Annotates assembly with addresses

## For SpinalHDL Migration

### jtbl.vhd → JopTypes.scala or BytecodeFetch.scala

**Approach 1: ROM-based** (literal translation)
```scala
class JumpTable extends Component {
  val io = new Bundle {
    val bytecode = in UInt(8 bits)
    val intPending = in Bool()
    val excPending = in Bool()
    val microcodeAddr = out UInt(11 bits)
  }

  // Could use a ROM initialized from data
  val jumpTable = Mem(UInt(11 bits), 256)
  jumpTable.initFromFile("jtbl_data.bin")

  io.microcodeAddr := jumpTable(io.bytecode)
}
```

**Approach 2: Case statement** (direct translation)
```scala
class JumpTable extends Component {
  val io = new Bundle {
    val bytecode = in UInt(8 bits)
    val microcodeAddr = out UInt(11 bits)
  }

  io.microcodeAddr := io.bytecode.mux(
    0x00 -> U"11'h218",  // nop
    0x01 -> U"11'h21A",  // aconst_null
    0xBB -> U"11'h07E",  // new
    // ... all 256 entries
    default -> U"11'h000"
  )
}
```

**Recommended**: Use ROM-based approach and generate initialization data from jtbl.vhd

### rom.vhd → MicrocodeRom.scala

```scala
class MicrocodeRom(config: JopConfig) extends Component {
  val io = new Bundle {
    val addr = in UInt(11 bits)
    val instruction = out Bits(32 bits)  // microcode instruction width
  }

  val rom = Mem(Bits(32 bits), 2048)  // 2^11 entries
  rom.initFromFile("microcode.bin")

  io.instruction := rom(io.addr)
}
```

## Extracting Data for SpinalHDL

### Script to Extract Jump Table

```python
#!/usr/bin/env python3
"""
Extract jump table data from jtbl.vhd for SpinalHDL
"""

import re

def parse_jtbl(vhdl_file):
    """Parse jtbl.vhd and extract mappings"""
    mappings = {}

    with open(vhdl_file) as f:
        for line in f:
            # Match: when "10111011" => addr <= "00001111110";
            match = re.search(r'when "([01]{8})" => addr <= "([01]{11})"', line)
            if match:
                bytecode = int(match.group(1), 2)
                addr = int(match.group(2), 2)
                mappings[bytecode] = addr

    return mappings

def generate_scala(mappings):
    """Generate Scala initialization data"""
    print("// Jump table data - Java bytecode to microcode address")
    print("val jumpTableData = Seq(")

    for bc in range(256):
        addr = mappings.get(bc, 0)
        print(f'  0x{bc:02X} -> U"11\'h{addr:03X}",  // {bc:3d} -> {addr:4d}')

    print(")")

# Usage
mappings = parse_jtbl('/home/peter/git/jop.arch/jop/asm/generated/jtbl.vhd')
generate_scala(mappings)
```

### Script to Extract Microcode ROM

```python
#!/usr/bin/env python3
"""
Extract microcode ROM data from rom.vhd for SpinalHDL
"""

def parse_rom(vhdl_file):
    """Parse rom.vhd and extract microcode"""
    # Parse the ROM VHDL and extract data
    # This is more complex due to ROM format
    pass

# TODO: Implement based on rom.vhd structure
```

## Important Notes

### DO NOT EDIT GENERATED FILES

- jtbl.vhd is **generated** - changes will be lost
- rom.vhd is **generated** - changes will be lost
- To modify: Edit microcode assembly source and reassemble

### Microcode Assembly

Location: `/home/peter/git/jop.arch/jop/asm/`

Source files:
- `jvm.asm` - Main JVM microcode source
- `Makefile` - Build system
- `Jopa.java` - Microcode assembler

To regenerate:
```bash
cd /home/peter/git/jop.arch/jop/asm
make
# Generates files in generated/
```

### Testing Strategy

For migration:

1. **Extract data** from generated files
2. **Create equivalent** SpinalHDL ROMs
3. **Verify** same mappings:
   - Test each bytecode → microcode address
   - Ensure all 256 bytecodes covered
   - Check special cases (interrupts, exceptions)

4. **Test vectors** should include:
   - All Java bytecode instructions (0x00-0xFF)
   - Interrupt pending cases
   - Exception pending cases

## References

### Java Bytecode Specification

See: [JVM Specification - Bytecode Instructions](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html)

Standard bytecodes (partial list):
- 0x00 - nop
- 0x01 - aconst_null
- 0x02 - iconst_m1
- 0x10 - bipush
- 0xB1 - return
- 0xB6 - invokevirtual
- 0xBB - new

### JOP Microcode

- Defined in `jvm.asm`
- Custom instruction set for stack operations
- Optimized for Java execution
- Includes:
  - Stack operations (push/pop)
  - ALU operations
  - Memory access
  - Control flow
  - Method invocation

## Migration Checklist

- [ ] Extract jump table data from jtbl.vhd
- [ ] Create JumpTable component in SpinalHDL
- [ ] Initialize with extracted data
- [ ] Create test vectors for all bytecodes
- [ ] Verify against original VHDL
- [ ] Extract microcode ROM data
- [ ] Create MicrocodeRom component
- [ ] Initialize with extracted data
- [ ] Integration test with full pipeline

## See Also

- [docs/MODULE_DEPENDENCIES.md](MODULE_DEPENDENCIES.md) - Module relationships
- [original/REFERENCE.md](../original/REFERENCE.md) - Reference structure
- bcfetch.vhd - Uses jump table
- fetch.vhd - Uses microcode ROM
