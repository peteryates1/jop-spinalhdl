# Jopa Modification - Scala Jump Table Generation

## Objective
Modify `java/jopa/src/com/jopdesign/tools/Jopa.java` to generate `JumpTableData.scala` for SpinalHDL alongside the existing `jtbl.vhd` output.

## Implementation

### 1. Add Scala Output Path Configuration

Add a command-line option to specify the Scala output directory:

```java
// In Jopa.java, add field:
private String scalaDir;  // Around line 72, with other directory fields

// In constructor (around line 100):
public Jopa(String fn, String src, String dst, String scala) {
    this.fname = fn;
    this.srcDir = src;
    this.dstDir = dst;
    this.scalaDir = scala;
    if (!srcDir.endsWith(File.separator))
        srcDir += File.separator;
    if (!dstDir.endsWith(File.separator))
        dstDir += File.separator;
    if (scalaDir != null && !scalaDir.endsWith(File.separator))
        scalaDir += File.separator;
}

// Update processOptions method (around line 104) to add -scala flag:
private void processOptions(String[] clist) {
    for (int i = 0; i < clist.length; i++) {
        if (clist[i].equals("-s")) {
            srcDir = clist[++i];
        } else if (clist[i].equals("-d")) {
            dstDir = clist[++i];
        } else if (clist[i].equals("-scala")) {
            scalaDir = clist[++i];  // NEW
        } else {
            fname = clist[i];
        }
    }
}
```

### 2. Add writeScalaJumpTable Method

Insert this method after the jtbl.vhd writing code (around line 555):

```java
/**
 * Write JumpTableData.scala for SpinalHDL
 * Maps Java bytecodes (0-255) to microcode ROM addresses
 */
private void writeScalaJumpTable(Map<Integer, Integer> bcToAddr,
                                  int noim_addr,
                                  int int_addr,
                                  int exc_addr) throws IOException {

    if (scalaDir == null) {
        return;  // Skip if no Scala output directory specified
    }

    FileWriter scala = new FileWriter(scalaDir + "JumpTableData.scala");

    StringBuilder sb = new StringBuilder();

    // File header
    sb.append("/*\n");
    sb.append(" * JumpTableData.scala\n");
    sb.append(" *\n");
    sb.append(" * Jump table for Java bytecode to JVM microcode address translation\n");
    sb.append(" *\n");
    sb.append(" * DO NOT EDIT THIS FILE!\n");
    sb.append(" * Generated by Jopa.java from microcode source (jvm.asm)\n");
    sb.append(" */\n");
    sb.append("\n");
    sb.append("package jop\n");
    sb.append("\n");
    sb.append("object JumpTableData {\n");
    sb.append("  /**\n");
    sb.append("   * Jump table entries (256 entries, indexed by Java bytecode)\n");
    sb.append("   * \n");
    sb.append("   * Each entry maps a Java bytecode (0x00-0xFF) to a microcode ROM address\n");
    sb.append("   * Default address for unmapped bytecodes: 0x" +
              String.format("%03X", noim_addr) + " (sys_noim)\n");
    sb.append("   */\n");
    sb.append("  def entries: Seq[BigInt] = Seq(\n");

    // Generate 256 entries (one per bytecode)
    for (int bc = 0; bc < 256; bc++) {
        Integer addr = bcToAddr.get(bc);
        String mnemonic;

        if (addr == null) {
            // Unmapped bytecode - use noim address
            addr = noim_addr;
            mnemonic = "unmapped -> sys_noim";
        } else {
            // Get mnemonic name
            mnemonic = JopInstr.name(bc);
            if (mnemonic == null) {
                mnemonic = "???";
            }
        }

        sb.append(String.format("    BigInt(0x%03X)", addr));
        if (bc < 255) {
            sb.append(",");
        }
        sb.append(String.format("  // 0x%02X: %s\n", bc, mnemonic));
    }

    sb.append("  )\n");
    sb.append("\n");

    // Add metadata
    sb.append("  /** Special addresses for interrupt/exception handling */\n");
    sb.append("  val sysNoimAddr = 0x" + String.format("%03X", noim_addr) +
              "  // sys_noim (not implemented)\n");
    sb.append("  val sysIntAddr  = 0x" + String.format("%03X", int_addr) +
              "  // sys_int (interrupt handler)\n");
    sb.append("  val sysExcAddr  = 0x" + String.format("%03X", exc_addr) +
              "  // sys_exc (exception handler)\n");
    sb.append("}\n");

    scala.write(sb.toString());
    scala.close();

    System.out.println("Generated Scala jump table: " + scalaDir + "JumpTableData.scala");
}
```

### 3. Modify pass2() to Collect Data and Call writeScalaJumpTable

In the `pass2()` method, we need to collect all bytecode â†’ address mappings:

```java
// Add this after line 360 (around where variables are declared):
Map<Integer, Integer> bcToAddrMap = new HashMap<Integer, Integer>();

// Then in the loop where jump table entries are written (around line 448-451),
// also add to our map:

if (l.jinstr!=-1) {
    ++ji_cnt;
    if (JopInstr.name(l.jinstr).equals("sys_int")) {
        int_address = pc;
    } else if (JopInstr.name(l.jinstr).equals("sys_exc")) {
        exc_address = pc;
    } else if (JopInstr.name(l.jinstr).equals("sys_noim")) {
        noim_address = pc;
    } else {
        jtbl.write("\t\twhen \""+bin(l.jinstr, 8) +
            "\" => addr <= \""+bin(pc, ADDRBITS)+"\";" +
            "\t--\t"+hex(pc,4)+"\t"+JopInstr.name(l.jinstr)+"\n");

        // NEW: Add to Scala map
        bcToAddrMap.put(l.jinstr, pc);
    }
}

// Then after jtbl.close() (around line 554), add:
// Write Scala jump table
writeScalaJumpTable(bcToAddrMap, noim_address, int_address, exc_address);
```

### 4. Update Makefile to Pass Scala Directory

Modify `asm/Makefile` to pass the `-scala` parameter:

```makefile
SCALA_OUT=../core/spinalhdl/src/main/scala/jop

all: ../java/jopa/dist/lib/jopa.jar
	mkdir -p generated
	mkdir -p $(SCALA_OUT)
	gcc -x c -E -C -P $(GCC_PARAMS) -D$(JVM_TYPE) src/$(ASM_SRC).asm > generated/$(ASM_SRC).asm
	sed -i '1,35d' generated/$(ASM_SRC).asm
	java -jar ../java/jopa/dist/lib/jopa.jar -s generated -d generated -scala $(SCALA_OUT) $(ASM_SRC).asm
```

## Testing

After implementing, rebuild everything:

```bash
cd /home/peter/workspaces/ai/jop/java/jopa
make clean && make

cd /home/peter/workspaces/ai/jop/asm
make clean && make
```

Expected output:
- `asm/generated/jtbl.vhd` (existing)
- `core/spinalhdl/src/main/scala/jop/JumpTableData.scala` (NEW)

## Verification

The generated Scala file should have:
1. 256 entries (one per bytecode)
2. Comments showing bytecode hex value and mnemonic
3. Correct microcode addresses matching jtbl.vhd
4. Metadata for special addresses (sys_noim, sys_int, sys_exc)

Example output:
```scala
object JumpTableData {
  def entries: Seq[BigInt] = Seq(
    BigInt(0x218),  // 0x00: nop
    BigInt(0x21A),  // 0x01: aconst_null
    BigInt(0x219),  // 0x02: iconst_m1
    // ... 256 total entries
  )

  val sysNoimAddr = 0x000  // sys_noim
  val sysIntAddr  = 0x000  // sys_int
  val sysExcAddr  = 0x000  // sys_exc
}
```

## Next Steps

After this modification:
1. Rebuild Jopa and microcode
2. Verify JumpTableData.scala is generated
3. Use in BytecodeFetchStage/JumpTable implementation
4. Test with SpinalHDL compilation
