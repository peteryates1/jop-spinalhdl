#!/usr/bin/env python3
"""
Extract jump table data from jtbl.vhd for SpinalHDL

This script parses the generated jtbl.vhd file and extracts the
Java bytecode to microcode address mappings.

Output can be used to initialize ROM in SpinalHDL.
"""

import re
import sys
from pathlib import Path
from typing import Dict


def parse_jtbl(vhdl_file: Path) -> Dict[int, int]:
    """
    Parse jtbl.vhd and extract bytecode → address mappings

    Args:
        vhdl_file: Path to jtbl.vhd

    Returns:
        Dictionary mapping bytecode (0-255) to microcode address
    """
    mappings = {}

    with open(vhdl_file) as f:
        for line in f:
            # Match: when "10111011" => addr <= "00001111110";
            match = re.search(r'when "([01]{8})" => addr <= "([01]{11})"', line)
            if match:
                bytecode = int(match.group(1), 2)
                addr = int(match.group(2), 2)
                mappings[bytecode] = addr

    return mappings


def generate_scala_object(mappings: Dict[int, int]) -> str:
    """
    Generate Scala object with jump table data

    Args:
        mappings: Bytecode to address mappings

    Returns:
        Scala source code
    """
    lines = [
        "package jop.generated",
        "",
        "import spinal.core._",
        "",
        "/**",
        " * Jump Table Data",
        " *",
        " * Maps Java bytecode (0x00-0xFF) to microcode ROM addresses.",
        " * Generated from jtbl.vhd",
        " *",
        " * DO NOT EDIT - Generated by extract_jtbl.py",
        " */",
        "object JumpTableData {",
        "",
        "  /**",
        "   * Jump table entries",
        "   * Index: Java bytecode (0-255)",
        "   * Value: Microcode ROM address (11 bits)",
        "   */",
        "  val entries: Seq[Int] = Seq(",
    ]

    # Generate all 256 entries (fill missing with 0)
    for bc in range(256):
        addr = mappings.get(bc, 0)
        comment = f"// 0x{bc:02X}: "

        # Add bytecode name if known
        if bc in BYTECODE_NAMES:
            comment += f"{BYTECODE_NAMES[bc]:20s}"
        else:
            comment += " " * 20

        comment += f" → 0x{addr:03X}"

        lines.append(f"    0x{addr:03X},  {comment}")

    lines.extend([
        "  )",
        "",
        "  /**",
        "   * Initialize a SpinalHDL Mem with jump table data",
        "   */",
        "  def initMem(mem: Mem[UInt]): Unit = {",
        "    entries.zipWithIndex.foreach { case (addr, bc) =>",
        "      mem.initialContent(bc) = addr",
        "    }",
        "  }",
        "}",
    ])

    return "\n".join(lines)


def generate_binary(mappings: Dict[int, int], output_file: Path) -> None:
    """
    Generate binary file for ROM initialization

    Args:
        mappings: Bytecode to address mappings
        output_file: Output binary file path
    """
    with open(output_file, 'wb') as f:
        for bc in range(256):
            addr = mappings.get(bc, 0)
            # Write as 16-bit little-endian (11 bits used)
            f.write(addr.to_bytes(2, byteorder='little'))


# Common Java bytecode names (partial list)
BYTECODE_NAMES = {
    0x00: "nop",
    0x01: "aconst_null",
    0x02: "iconst_m1",
    0x03: "iconst_0",
    0x04: "iconst_1",
    0x05: "iconst_2",
    0x10: "bipush",
    0x11: "sipush",
    0x12: "ldc",
    0x13: "ldc_w",
    0x15: "iload",
    0x19: "aload",
    0x1A: "iload_0",
    0x1B: "iload_1",
    0x2A: "aload_0",
    0x2B: "aload_1",
    0x36: "istore",
    0x3A: "astore",
    0x3B: "istore_0",
    0x4B: "astore_0",
    0x57: "pop",
    0x59: "dup",
    0x60: "iadd",
    0x64: "isub",
    0x68: "imul",
    0x6C: "idiv",
    0x84: "iinc",
    0x99: "ifeq",
    0x9A: "ifne",
    0x9F: "if_icmpeq",
    0xA0: "if_icmpne",
    0xA2: "if_icmpge",
    0xA7: "goto",
    0xAC: "ireturn",
    0xAD: "lreturn",
    0xAE: "freturn",
    0xAF: "dreturn",
    0xB0: "areturn",
    0xB1: "return",
    0xB2: "getstatic",
    0xB3: "putstatic",
    0xB4: "getfield",
    0xB5: "putfield",
    0xB6: "invokevirtual",
    0xB7: "invokespecial",
    0xB8: "invokestatic",
    0xB9: "invokeinterface",
    0xBB: "new",
    0xBC: "newarray",
    0xBD: "anewarray",
    0xBE: "arraylength",
    0xC0: "checkcast",
    0xC1: "instanceof",
}


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description='Extract jump table from jtbl.vhd'
    )
    parser.add_argument(
        '--input',
        type=Path,
        default=Path('/home/peter/git/jop.arch/jop/asm/generated/jtbl.vhd'),
        help='Path to jtbl.vhd'
    )
    parser.add_argument(
        '--output-scala',
        type=Path,
        default=Path('core/spinalhdl/src/main/scala/jop/generated/JumpTableData.scala'),
        help='Output Scala file'
    )
    parser.add_argument(
        '--output-bin',
        type=Path,
        default=Path('verification/test-vectors/generated/jtbl.bin'),
        help='Output binary file'
    )
    parser.add_argument(
        '--stats',
        action='store_true',
        help='Show statistics'
    )

    args = parser.parse_args()

    # Parse input
    if not args.input.exists():
        print(f"Error: Input file not found: {args.input}", file=sys.stderr)
        return 1

    print(f"Parsing {args.input}...")
    mappings = parse_jtbl(args.input)

    # Statistics
    if args.stats:
        print(f"\nStatistics:")
        print(f"  Total bytecodes defined: {len(mappings)}")
        print(f"  Unique microcode addresses: {len(set(mappings.values()))}")
        print(f"  Address range: 0x{min(mappings.values()):03X} - 0x{max(mappings.values()):03X}")

    # Generate Scala
    print(f"\nGenerating Scala: {args.output_scala}...")
    args.output_scala.parent.mkdir(parents=True, exist_ok=True)
    scala_code = generate_scala_object(mappings)
    with open(args.output_scala, 'w') as f:
        f.write(scala_code)
    print(f"  Written {len(scala_code)} bytes")

    # Generate binary
    print(f"\nGenerating binary: {args.output_bin}...")
    args.output_bin.parent.mkdir(parents=True, exist_ok=True)
    generate_binary(mappings, args.output_bin)
    print(f"  Written {args.output_bin.stat().st_size} bytes")

    print("\n✓ Done!")
    return 0


if __name__ == '__main__':
    sys.exit(main())
