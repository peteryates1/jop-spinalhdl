package jop.pipeline

import spinal.core._
import jop.JumpTableData

/**
 * Jump Table Configuration
 *
 * Configures the jump table parameters for bytecode-to-microcode address translation.
 *
 * @param pcWidth Address bits of microcode ROM (default: 11 bits = 2K instructions)
 */
case class JumpTableConfig(
  pcWidth: Int = 11
) {
  require(pcWidth > 0, "PC width must be positive")
  require(pcWidth <= 16, "PC width too large (max 16 bits)")

  /** Number of bytecode entries (always 256 for Java bytecode) */
  def entries: Int = 256
}

/**
 * Jump Table - Java Bytecode to Microcode Address Translation
 *
 * Translates 8-bit Java bytecode opcodes to microcode ROM addresses.
 * Uses ROM-based lookup with data generated by Jopa assembler.
 *
 * Architecture:
 * - ROM with 256 entries (one per bytecode 0x00-0xFF)
 * - Asynchronous/combinational read
 * - Initialized from JumpTableData.scala (generated by Jopa)
 *
 * Data Flow:
 * 1. bytecode (8 bits) → ROM address
 * 2. ROM lookup (combinational)
 * 3. jpaddr (pcWidth bits) → microcode fetch stage
 *
 * Special Addresses (from JumpTableData):
 * - sys_noim (0x0EC): Not implemented instruction handler
 * - sys_int  (0x0DA): Interrupt handler
 * - sys_exc  (0x0E2): Exception handler
 *
 * Timing:
 * - Combinational output (0 cycle latency)
 * - Used as address input to microcode ROM
 *
 * Generated From:
 * - asm/generated/JumpTableData.scala (auto-generated by Jopa)
 * - Original: original/vhdl/core/jtbl.vhd
 *
 * @param config Jump table configuration
 */
case class JumpTable(
  config: JumpTableConfig = JumpTableConfig()
) extends Component {

  val io = new Bundle {
    val bytecode = in Bits(8 bits)              // Java bytecode opcode (0x00-0xFF)
    val jpaddr   = out UInt(config.pcWidth bits) // Microcode ROM address
  }

  // ==========================================================================
  // Jump Table ROM
  // ==========================================================================

  // ROM stores microcode addresses (256 entries, one per bytecode)
  val rom = Mem(UInt(config.pcWidth bits), config.entries)

  // Initialize from Jopa-generated data
  rom.init(JumpTableData.entries.map(addr => U(addr.toInt, config.pcWidth bits)))

  // ==========================================================================
  // Lookup Logic
  // ==========================================================================

  // Asynchronous ROM read (combinational, 0-cycle latency)
  // bytecode → ROM address → microcode address
  // Note: readAsync generates a Verilog warning "can only be write first"
  //       This is safe here since ROM has no writes (read-only data)
  io.jpaddr := rom.readAsync(io.bytecode.asUInt)

  // ==========================================================================
  // Verification Helpers
  // ==========================================================================

  // Add assertions for debugging (disabled in synthesis)
  if (GenerationFlags.simulation) {
    // Verify bytecode is in valid range
    assert(
      assertion = io.bytecode.asUInt < config.entries,
      message = "Invalid bytecode out of range",
      severity = WARNING
    )

    // Verify output address is in valid microcode ROM range
    assert(
      assertion = io.jpaddr < (1 << config.pcWidth),
      message = "Jump address out of microcode ROM range",
      severity = WARNING
    )
  }
}

/**
 * JumpTable Companion Object
 *
 * Provides utility functions and constants.
 */
object JumpTable {

  /**
   * Special microcode addresses (from JumpTableData)
   */
  object SpecialAddr {
    val SYS_NOIM = JumpTableData.sysNoimAddr  // 0x0EC - Not implemented
    val SYS_INT  = JumpTableData.sysIntAddr   // 0x0DA - Interrupt
    val SYS_EXC  = JumpTableData.sysExcAddr   // 0x0E2 - Exception
  }

  /**
   * Get microcode address for a specific bytecode (for testing)
   */
  def getAddress(bytecode: Int): Int = {
    require(bytecode >= 0 && bytecode < 256, "Bytecode out of range")
    JumpTableData.entries(bytecode).toInt
  }

  /**
   * Generate Verilog for standalone testing
   */
  def main(args: Array[String]): Unit = {
    SpinalConfig(
      mode = Verilog,
      targetDirectory = "core/spinalhdl/generated"
    ).generate(JumpTable())
  }
}
